 lin-update
<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AS-REP ROASTING | polmoreno</title><meta name=keywords content="attack,active directory,kerberos"><meta name=description content="Abusing As-Rep Roasting on Active Directory."><meta name=author content="Pol Moreno"><link rel=canonical href=https://polmoreno.github.io/posts/as-rep-roasting/><link crossorigin=anonymous href=../../assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://polmoreno.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://polmoreno.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://polmoreno.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://polmoreno.github.io/apple-touch-icon.png><link rel=mask-icon href=https://polmoreno.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="AS-REP ROASTING"><meta property="og:description" content="Abusing As-Rep Roasting on Active Directory."><meta property="og:type" content="article"><meta property="og:url" content="https://polmoreno.github.io/posts/as-rep-roasting/"><meta property="og:image" content="https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-23T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-23T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png"><meta name=twitter:title content="AS-REP ROASTING"><meta name=twitter:description content="Abusing As-Rep Roasting on Active Directory."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://polmoreno.github.io/posts/"},{"@type":"ListItem","position":3,"name":"AS-REP ROASTING","item":"https://polmoreno.github.io/posts/as-rep-roasting/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AS-REP ROASTING","name":"AS-REP ROASTING","description":"Abusing As-Rep Roasting on Active Directory.","keywords":["attack","active directory","kerberos"],"articleBody":" AS-REP roasting is a form of attack on the Kerberos authentication protocol that takes advantage of a known weakness in the protocol that can be exploited during initial authentication with a Key Distribution Center (KDC).\nSo here’s the scenario:\nYou have a system that interfaces with a really slow third-party API. User Bob, needs some data, so your system performs a request to the third-party API, and waits for a response. In the meantime, user Alice needs the same date and the system performs the same request to the API on behalf of her. Both users are now waiting for two requests that the only difference they have, is the execution time.\nIf a request to this API has an average response time of 1 second, both users will wait 1 second. Also, you would need to occupy resources in your system and the third-party API for more than 1 second, and for 2 seconds at most!\nThe solution What if you could have both users, Bob and Alice, wait for the same request? Then, although Bob will still wait for the request for 1 second, Alice will use Bob’s request, and wait less time for the response.\nTo achieve that, we’ll need a promise-cache subsystem. This subsystem will consist of a data structure to store our requests’ promises and of a way to retrieve them/delete them when they are not needed.\nThe data structure We need a data structure to store our promises inside. This data structure needs to be able to store and retrieve a new promise in one operation (O(1)). So, the best choice would be a key/value store. Javascript, offers two such structures, the basic object and the Map() instance. The most preferrable data structure for our use-case among the two is the Map().\nSo, let’s create it:\nconst promiseCache: Map\u003cstring, Promise\u003cResponse\u003e\u003e = new Map(); The retrieval/storage Now, let’s create a function that wraps around the request function and retrieves the same promise for the same request, if it exists. If it doesn’t, it performs a new request and stores it in the cache.\nfunction memoizedRequest(url: string) { const key = url; if (promiseCache.has(key)) { return promiseCache.get(key); } const promise = request(url); promiseCache.set(key, promise); return promise; } With this, we have achieved the basic function of our promise-cache subsystem. When our system performs a request using the memoizedRequest function, and the request has already happened, it returns the same promise.\nBut, we haven’t yet implemented the mechanism for the deletion of the promise from the cache when the promise resolves (when the request returns results)\nThe deletion - cache invalidation For this, we’ll create a function that awaits for the promise to resolve and then delete the promise from the cache.\nasync function promiseInvalidator(key: string, promise: Promise\u003cany\u003e) { await promise; promiseCache.delete(key); return promise; } And then we’ll modify our memoizedRequest function to include this invalidation function:\nfunction memoizedRequest(url: string) { const key = url; if (promiseCache.has(key)) { return promiseCache.get(key); } const promise = promiseInvalidator(key, request(url)); promiseCache.set(key, promise); return promise; } But what happens with more complicated requests? Not all requests can be differentiated by just the url they are performed on. There are many other parameters that make a request different (eg: headers, body etc).\nFor that, we’ll need to refine our promise-cache’s key and add an options object on our function:\nfunction memoizedRequest(url: string, options: RequestOptions) { const key = url + JSON.stringify(options); if (promiseCache.has(key)) { return promiseCache.get(key); } const promise = promiseInvalidator(key, request(url)); promiseCache.set(key, promise); return promise; } Now, only the requests that use exactly the same options will return the same promise until they resolve.\nWith this, we implemented all the basic functionality of our package. But we haven’t taken into account the possibility of a request failure. Let’s add this on our code, by making the promiseInvalidator function to always remove the promise from the cache either when it resolves, or when it rejects.\nasync function promiseInvalidator(key: string, promise: Promise\u003cany\u003e) { try { await promise; } finally { promiseCache.delete(key); } return promise; } More improvements This implementation has a small drawback, that can prove serious on a production system. All the requests’ data, are stored within the key of our data store, highly increasing the memory requirements of our application, especially when our requests contain a lot of data. The solution to this is to use a hash function on our key, to assign a unique value to each different request, without needing to include all the actual of the request.\nconst key = hasher(url + JSON.stringify(options)); Caveats This solution, isn’t applicable to any situation. To use this solution, you need to ensure that the API you are interfacing with, is not providing different responses for two different requests in the amount of time it will take for those requests to resolve.\nThe package If you don’t want to code this for yourself, I created a simple npm package that does all of the above, as a wrapper to node-fetch (or any other fetch-like function you choose).\nimport memoizedNodeFetch from 'memoized-node-fetch'; const fetch = memoizedNodeFetch(); (async () =\u003e { const fetch1 = fetch('https://jsonplaceholder.typicode.com/todos/1'); const fetch2 = fetch('https://jsonplaceholder.typicode.com/todos/1'); // This should return true because both requests return the same promise. console.log(fetch1 === fetch2); const res1 = await fetch1; const res2 = await fetch2; console.log(await res1.json()); console.log(await res2.json()); })(); You can see all of the above work, on its Github repository here:\nhttps://github.com/chrispanag/memoized-node-fetch\nPS. 1: Although this can be used in the front-end, I can’t find a very useful use-case for it, especially when you have other packages such as react-query/swr, that although they perform a different function than the above, can sometimes remove the need for it.\nPS. 2: Special thanks to the other two contributors of this repository (ferrybig and Bonjur for their invaluable input and suggestions!\n","wordCount":"965","inLanguage":"en","image":"https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png","datePublished":"2022-10-23T00:00:00Z","dateModified":"2022-10-23T00:00:00Z","author":{"@type":"Person","name":"Pol Moreno"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://polmoreno.github.io/posts/as-rep-roasting/"},"publisher":{"@type":"Organization","name":"polmoreno","logo":{"@type":"ImageObject","url":"https://polmoreno.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://polmoreno.github.io accesskey=h title="polmoreno (Alt + H)">polmoreno</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://polmoreno.github.io/about title="about me"><span>about me</span></a></li><li><a href=https://polmoreno.github.io/posts title=blog><span>blog</span></a></li><li><a href=https://polmoreno.github.io/categories/ title=categories><span>categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>AS-REP ROASTING</h1><div class=post-description>Abusing As-Rep Roasting on Active Directory.</div><div class=post-meta><span title='2022-10-23 00:00:00 +0000 UTC'>October 23, 2022</span>&nbsp;·&nbsp;Pol Moreno</div></header><figure class=entry-cover><img loading=lazy srcset="https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover_hu471e03bbe00a943b870f93ea03b8aad5_19008_360x0_resize_box_3.png 360w ,https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover_hu471e03bbe00a943b870f93ea03b8aad5_19008_480x0_resize_box_3.png 480w ,https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png 607w" sizes="(min-width: 768px) 720px, 100vw" src=https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png alt width=607 height=322></figure><div class=post-content><blockquote><p>AS-REP roasting is a form of attack on the Kerberos authentication protocol that takes advantage of a known weakness in the protocol that can be exploited during initial authentication with a Key Distribution Center (KDC).</p></blockquote><p><strong>So here&rsquo;s the scenario:</strong></p><p>You have a system that interfaces with a really slow third-party API. User Bob, needs some data, so your system performs a request to the third-party API, and waits for a response. In the meantime, user Alice needs the same date and the system performs the same request to the API on behalf of her. Both users are now waiting for two requests that the only difference they have, is the execution time.</p><p>If a request to this API has an average response time of 1 second, both users will wait 1 second. Also, you would need to occupy resources in your system and the third-party API for more than 1 second, and for 2 seconds at most!</p><h2 id=the-solution>The solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2><p>What if you could have both users, Bob and Alice, wait for the same request? Then, although Bob will still wait for the request for 1 second, Alice will use Bob&rsquo;s request, and wait less time for the response.</p><p>To achieve that, we&rsquo;ll need a <strong>promise-cache subsystem</strong>. This subsystem will consist of a data structure to store our requests&rsquo; promises and of a way to retrieve them/delete them when they are not needed.</p><h3 id=the-data-structure>The data structure<a hidden class=anchor aria-hidden=true href=#the-data-structure>#</a></h3><p>We need a data structure to store our promises inside. This data structure needs to be able to store and retrieve a new promise in one operation (O(1)). So, the best choice would be a key/value store. Javascript, offers two such structures, the <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>basic object</a> and the <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map>Map()</a> instance. The <a href=https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373>most preferrable data structure for our use-case among the two is the Map()</a>.</p><p>So, let&rsquo;s create it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promiseCache</span>: <span style=color:#66d9ef>Map</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Promise</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>Response</span>&gt;<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>();
</span></span></code></pre></div><h3 id=the-retrievalstorage>The retrieval/storage<a hidden class=anchor aria-hidden=true href=#the-retrievalstorage>#</a></h3><p>Now, let&rsquo;s create a function that wraps around the request function and retrieves the same promise for the same request, if it exists. If it doesn&rsquo;t, it performs a new request and stores it in the cache.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>memoizedRequest</span>(<span style=color:#a6e22e>url</span>: <span style=color:#66d9ef>string</span>) {
<!doctype html>
<html lang=en dir=auto>

<head>
    <meta charset=utf-8>
    <meta http-equiv=x-ua-compatible content="IE=edge">
    <meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
    <meta name=robots content="index, follow">
    <title>AS-REP ROASTING | polmoreno</title>
    <meta name=keywords content="attack,active directory,kerberos">
    <meta name=description content="Abusing As-Rep Roasting on Active Directory.">
    <meta name=author content="Pol Moreno">
    <link rel=canonical href=https://polmoreno.github.io/posts/as-rep-roasting />
    <link crossorigin=anonymous
        href=../../assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css
        integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style>
    <script defer crossorigin=anonymous
        src=../../assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js
        integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
    <link rel=icon href=https://polmoreno.github.io/favicon.ico>
    <link rel=icon type=image/png sizes=16x16 href=https://polmoreno.github.io/favicon-16x16.png>
    <link rel=icon type=image/png sizes=32x32 href=https://polmoreno.github.io/favicon-32x32.png>
    <link rel=apple-touch-icon href=https://polmoreno.github.io/apple-touch-icon.png>
    <link rel=mask-icon href=https://polmoreno.github.io/safari-pinned-tab.svg>
    <meta name=theme-color content="#2e2e33">
    <meta name=msapplication-TileColor content="#2e2e33"><noscript>
        <style>
            #theme-toggle,
            .top-link {
                display: none
            }
        </style>
        <style>
            @media(prefers-color-scheme:dark) {
                :root {
                    --theme: rgb(29, 30, 32);
                    --entry: rgb(46, 46, 51);
                    --primary: rgb(218, 218, 219);
                    --secondary: rgb(155, 156, 157);
                    --tertiary: rgb(65, 66, 68);
                    --content: rgb(196, 196, 197);
                    --hljs-bg: rgb(46, 46, 51);
                    --code-bg: rgb(55, 56, 62);
                    --border: rgb(51, 51, 51)
                }

                .list {
                    background: var(--theme)
                }

                .list:not(.dark)::-webkit-scrollbar-track {
                    background: 0 0
                }

                .list:not(.dark)::-webkit-scrollbar-thumb {
                    border-color: var(--theme)
                }
            }
        </style>
    </noscript>
    <meta property="og:title" content="AS-REP ROASTING">
    <meta property="og:description" content="Abusing As-Rep Roasting on Active Directory.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://polmoreno.github.io/posts/as-rep-roasting/">
    <meta property="og:image" content="https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-07-09T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-07-09T00:00:00+00:00">
    <meta name=twitter:card content="summary_large_image">
    <meta name=twitter:image content="https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png">
    <meta name=twitter:title content="AS-REP ROASTING">
    <meta name=twitter:description content="Abusing As-Rep Roasting on Active Directory.">
    <script
        type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://polmoreno.github.io/posts/"},{"@type":"ListItem","position":3,"name":"AS-REP ROASTING","item":"https://polmoreno.github.io/posts/as-rep-roasting/"}]}</script>
    <script
        type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AS-REP ROASTING","name":"AS-REP ROASTING","description":"Abusing As-Rep Roasting on Active Directory.","keywords":["attack","active directory","kerberos"],"articleBody":" TLDR; I created a small npm package that acts as a wrapper around node-fetch, and returns the same promise for the same request, until it resolves. You can visit the repo of this package here. Below, I explain my motivation, and how I tackled the issue.\nSo here’s the scenario:\nYou have a system that interfaces with a really slow third-party API. User Bob, needs some data, so your system performs a request to the third-party API, and waits for a response. In the meantime, user Alice needs the same date and the system performs the same request to the API on behalf of her. Both users are now waiting for two requests that the only difference they have, is the execution time.\nIf a request to this API has an average response time of 1 second, both users will wait 1 second. Also, you would need to occupy resources in your system and the third-party API for more than 1 second, and for 2 seconds at most!\nThe solution What if you could have both users, Bob and Alice, wait for the same request? Then, although Bob will still wait for the request for 1 second, Alice will use Bob’s request, and wait less time for the response.\nTo achieve that, we’ll need a promise-cache subsystem. This subsystem will consist of a data structure to store our requests’ promises and of a way to retrieve them/delete them when they are not needed.\nThe data structure We need a data structure to store our promises inside. This data structure needs to be able to store and retrieve a new promise in one operation (O(1)). So, the best choice would be a key/value store. Javascript, offers two such structures, the basic object and the Map() instance. The most preferrable data structure for our use-case among the two is the Map().\nSo, let’s create it:\nconst promiseCache: Map\u003cstring, Promise\u003cResponse\u003e\u003e = new Map(); The retrieval/storage Now, let’s create a function that wraps around the request function and retrieves the same promise for the same request, if it exists. If it doesn’t, it performs a new request and stores it in the cache.\nfunction memoizedRequest(url: string) { const key = url; if (promiseCache.has(key)) { return promiseCache.get(key); } const promise = request(url); promiseCache.set(key, promise); return promise; } With this, we have achieved the basic function of our promise-cache subsystem. When our system performs a request using the memoizedRequest function, and the request has already happened, it returns the same promise.\nBut, we haven’t yet implemented the mechanism for the deletion of the promise from the cache when the promise resolves (when the request returns results)\nThe deletion - cache invalidation For this, we’ll create a function that awaits for the promise to resolve and then delete the promise from the cache.\nasync function promiseInvalidator(key: string, promise: Promise\u003cany\u003e) { await promise; promiseCache.delete(key); return promise; } And then we’ll modify our memoizedRequest function to include this invalidation function:\nfunction memoizedRequest(url: string) { const key = url; if (promiseCache.has(key)) { return promiseCache.get(key); } const promise = promiseInvalidator(key, request(url)); promiseCache.set(key, promise); return promise; } But what happens with more complicated requests? Not all requests can be differentiated by just the url they are performed on. There are many other parameters that make a request different (eg: headers, body etc).\nFor that, we’ll need to refine our promise-cache’s key and add an options object on our function:\nfunction memoizedRequest(url: string, options: RequestOptions) { const key = url + JSON.stringify(options); if (promiseCache.has(key)) { return promiseCache.get(key); } const promise = promiseInvalidator(key, request(url)); promiseCache.set(key, promise); return promise; } Now, only the requests that use exactly the same options will return the same promise until they resolve.\nWith this, we implemented all the basic functionality of our package. But we haven’t taken into account the possibility of a request failure. Let’s add this on our code, by making the promiseInvalidator function to always remove the promise from the cache either when it resolves, or when it rejects.\nasync function promiseInvalidator(key: string, promise: Promise\u003cany\u003e) { try { await promise; } finally { promiseCache.delete(key); } return promise; } More improvements This implementation has a small drawback, that can prove serious on a production system. All the requests’ data, are stored within the key of our data store, highly increasing the memory requirements of our application, especially when our requests contain a lot of data. The solution to this is to use a hash function on our key, to assign a unique value to each different request, without needing to include all the actual of the request.\nconst key = hasher(url + JSON.stringify(options)); Caveats This solution, isn’t applicable to any situation. To use this solution, you need to ensure that the API you are interfacing with, is not providing different responses for two different requests in the amount of time it will take for those requests to resolve.\nThe package If you don’t want to code this for yourself, I created a simple npm package that does all of the above, as a wrapper to node-fetch (or any other fetch-like function you choose).\nimport memoizedNodeFetch from 'memoized-node-fetch'; const fetch = memoizedNodeFetch(); (async () =\u003e { const fetch1 = fetch('https://jsonplaceholder.typicode.com/todos/1'); const fetch2 = fetch('https://jsonplaceholder.typicode.com/todos/1'); // This should return true because both requests return the same promise. console.log(fetch1 === fetch2); const res1 = await fetch1; const res2 = await fetch2; console.log(await res1.json()); console.log(await res2.json()); })(); You can see all of the above work, on its Github repository here:\nhttps://github.com/chrispanag/memoized-node-fetch\nPS. 1: Although this can be used in the front-end, I can’t find a very useful use-case for it, especially when you have other packages such as react-query/swr, that although they perform a different function than the above, can sometimes remove the need for it.\nPS. 2: Special thanks to the other two contributors of this repository (ferrybig and Bonjur for their invaluable input and suggestions!\n","wordCount":"976","inLanguage":"en","image":"https://polmoreno.github.io/posts/as-rep-roasting/asreproasting_cover.png","datePublished":"2022-07-09T00:00:00Z","dateModified":"2022-07-09T00:00:00Z","author":{"@type":"Person","name":"Pol Moreno"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://polmoreno.github.io/posts/as-rep-roasting/"},"publisher":{"@type":"Organization","name":"polmoreno","logo":{"@type":"ImageObject","url":"https://polmoreno.github.io/favicon.ico"}}}</script>
</head>

<body id=top>
    <script>localStorage.getItem("pref-theme") === "dark" ? document.body.classList.add("dark") : localStorage.getItem("pref-theme") === "light" ? document.body.classList.remove("dark") : window.matchMedia("(prefers-color-scheme: dark)").matches && document.body.classList.add("dark")</script>
    <header class=header>
        <nav class=nav>
            <div class=logo><a href=https://polmoreno.github.io accesskey=h title="polmoreno (Alt + H)">polmoreno</a>
                <div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon"
                            xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none"
                            stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />
                        </svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18"
                            viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5" />
                            <line x1="12" y1="1" x2="12" y2="3" />
                            <line x1="12" y1="21" x2="12" y2="23" />
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
                            <line x1="1" y1="12" x2="3" y2="12" />
                            <line x1="21" y1="12" x2="23" y2="12" />
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
                        </svg></button></div>
            </div>
            <ul id=menu>
                <li><a href=https://polmoreno.github.io/about title="about me"><span>about me</span></a></li>
                <li><a href=https://polmoreno.github.io/posts title=blog><span>blog</span></a></li>
                <li><a href=https://polmoreno.github.io/categories/ title=categories><span>categories</span></a></li>
            </ul>
        </nav>
    </header>
    <main class=main>
        <article class=post-single>
            <header class=post-header>
                <h1 class=post-title>AS-REP ROASTING</h1>
                <div class=post-description>Abusing As-Rep Roasting on Active Directory.</div>
                <div class=post-meta><span title='2022-07-09 00:00:00 +0000 UTC'>July 9, 2022</span>&nbsp;·&nbsp;Pol
                    Moreno</div>
            </header>
            <div class=post-content>
                <blockquote>
                    <p>TLDR; I created a small npm package that acts as a wrapper around node-fetch, and returns the
                        same promise for the same request, until it resolves. You can visit the repo of this package <a
                            href=https://github.com/chrispanag/memoized-node-fetch>here</a>. Below, I explain my
                        motivation, and how I tackled the issue.</p>
                </blockquote>
                <p><strong>So here&rsquo;s the scenario:</strong></p>
                <p>You have a system that interfaces with a really slow third-party API. User Bob, needs some data, so
                    your system performs a request to the third-party API, and waits for a response. In the meantime,
                    user Alice needs the same date and the system performs the same request to the API on behalf of her.
                    Both users are now waiting for two requests that the only difference they have, is the execution
                    time.</p>
                <p>If a request to this API has an average response time of 1 second, both users will wait 1 second.
                    Also, you would need to occupy resources in your system and the third-party API for more than 1
                    second, and for 2 seconds at most!</p>
                <h2 id=the-solution>The solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2>
                <p>What if you could have both users, Bob and Alice, wait for the same request? Then, although Bob will
                    still wait for the request for 1 second, Alice will use Bob&rsquo;s request, and wait less time for
                    the response.</p>
                <p>To achieve that, we&rsquo;ll need a <strong>promise-cache subsystem</strong>. This subsystem will
                    consist of a data structure to store our requests&rsquo; promises and of a way to retrieve
                    them/delete them when they are not needed.</p>
                <h3 id=the-data-structure>The data structure<a hidden class=anchor aria-hidden=true
                        href=#the-data-structure>#</a></h3>
                <p>We need a data structure to store our promises inside. This data structure needs to be able to store
                    and retrieve a new promise in one operation (O(1)). So, the best choice would be a key/value store.
                    Javascript, offers two such structures, the <a
                        href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>basic
                        object</a> and the <a
                        href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map>Map()</a>
                    instance. The <a
                        href=https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373>most
                        preferrable data structure for our use-case among the two is the Map()</a>.</p>
                <p>So, let&rsquo;s create it:</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promiseCache</span>: <span style=color:#66d9ef>Map</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Promise</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>Response</span>&gt;<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>();
</span></span></code></pre>
                </div>
                <h3 id=the-retrievalstorage>The retrieval/storage<a hidden class=anchor aria-hidden=true
                        href=#the-retrievalstorage>#</a></h3>
                <p>Now, let&rsquo;s create a function that wraps around the request function and retrieves the same
                    promise for the same request, if it exists. If it doesn&rsquo;t, it performs a new request and
                    stores it in the cache.</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>memoizedRequest</span>(<span style=color:#a6e22e>url</span>: <span style=color:#66d9ef>string</span>) {
 main
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>url</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>promiseCache</span>.<span style=color:#a6e22e>has</span>(<span style=color:#a6e22e>key</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>key</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promise</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>request</span>(<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>promise</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promise</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre>
                </div>
                <p>With this, we have achieved the basic function of our promise-cache subsystem. When our system
                    performs a request using the <code>memoizedRequest</code> function, and the request has already
                    happened, it returns the same promise.</p>
                <p>But, we haven&rsquo;t yet implemented the mechanism for the deletion of the promise from the cache
                    when the promise resolves (when the request returns results)</p>
                <h3 id=the-deletion---cache-invalidation>The deletion - cache invalidation<a hidden class=anchor
                        aria-hidden=true href=#the-deletion---cache-invalidation>#</a></h3>
                <p>For this, we&rsquo;ll create a function that awaits for the promise to resolve and then delete the
                    promise from the cache.</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>promiseInvalidator</span>(<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>promise</span>: <span style=color:#66d9ef>Promise</span>&lt;<span style=color:#f92672>any</span>&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>promise</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>key</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promise</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre>
                </div>
                <p>And then we&rsquo;ll modify our memoizedRequest function to include this invalidation function:</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>memoizedRequest</span>(<span style=color:#a6e22e>url</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>url</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>promiseCache</span>.<span style=color:#a6e22e>has</span>(<span style=color:#a6e22e>key</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>key</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promise</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>promiseInvalidator</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>request</span>(<span style=color:#a6e22e>url</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>promise</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promise</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre>
                </div>
                <h3 id=but-what-happens-with-more-complicated-requests>But what happens with more complicated
                    requests?<a hidden class=anchor aria-hidden=true
                        href=#but-what-happens-with-more-complicated-requests>#</a></h3>
                <p>Not all requests can be differentiated by just the url they are performed on. There are many other
                    parameters that make a request different (eg: headers, body etc).</p>
                <p>For that, we&rsquo;ll need to refine our promise-cache&rsquo;s key and add an options object on our
                    function:</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>memoizedRequest</span>(<span style=color:#a6e22e>url</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>options</span>: <span style=color:#66d9ef>RequestOptions</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>options</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>promiseCache</span>.<span style=color:#a6e22e>has</span>(<span style=color:#a6e22e>key</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>key</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promise</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>promiseInvalidator</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>request</span>(<span style=color:#a6e22e>url</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>promise</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promise</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre>
                </div>
                <p>Now, <strong>only the requests that use exactly the same options</strong> will return the same
                    promise until they resolve.</p>
                <p>With this, we implemented all the basic functionality of our package. But we haven&rsquo;t taken into
                    account the possibility of a request failure. Let&rsquo;s add this on our code, by making the
                    <code>promiseInvalidator</code> function to always remove the promise from the cache either when it
                    resolves, or when it rejects.</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>promiseInvalidator</span>(<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>promise</span>: <span style=color:#66d9ef>Promise</span>&lt;<span style=color:#f92672>any</span>&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>promise</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>promiseCache</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>key</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promise</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre>
                </div>
                <h3 id=more-improvements>More improvements<a hidden class=anchor aria-hidden=true
                        href=#more-improvements>#</a></h3>
                <p>This implementation has a small drawback, that can prove serious on a production system. All the
                    requests&rsquo; data, are stored within the key of our data store, highly increasing the memory
                    requirements of our application, especially when our requests contain a lot of data. The solution to
                    this is to use a <a href=https://en.wikipedia.org/wiki/Hash_function>hash function</a> on our key,
                    to assign a unique value to each different request, without needing to include all the actual of the
                    request.</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>url</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>options</span>));
</span></span></code></pre>
                </div>
                <h3 id=caveats>Caveats<a hidden class=anchor aria-hidden=true href=#caveats>#</a></h3>
                <p>This solution, isn&rsquo;t applicable to any situation. To use this solution, you need to ensure that
                    the API you are interfacing with, <strong>is not providing different responses for two different
                        requests</strong> in the amount of time it will take for those requests to resolve.</p>
                <h2 id=the-package>The package<a hidden class=anchor aria-hidden=true href=#the-package>#</a></h2>
                <p>If you don&rsquo;t want to code this for yourself, I created a simple <a
                        href=https://www.npmjs.com/package/memoized-node-fetch><strong>npm package</strong></a> that
                    does all of the above, as a wrapper to <a
                        href=https://www.npmjs.com/package/node-fetch>node-fetch</a> (or any other fetch-like function
                    you choose).</p>
                <div class=highlight>
                    <pre tabindex=0
                        style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>memoizedNodeFetch</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;memoized-node-fetch&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetch</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>memoizedNodeFetch</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>async</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetch1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;https://jsonplaceholder.typicode.com/todos/1&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetch2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;https://jsonplaceholder.typicode.com/todos/1&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This should return true because both requests return the same promise.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fetch1</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>fetch2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>await</span> <span style=color:#a6e22e>res1</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>await</span> <span style=color:#a6e22e>res2</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>})();
 lin-update
</span></span></code></pre></div><p>You can see all of the above work, on its Github repository here:</p><p><a href=https://github.com/chrispanag/memoized-node-fetch>https://github.com/chrispanag/memoized-node-fetch</a></p><p>PS. 1: Although this can be used in the front-end, I can&rsquo;t find a very useful use-case for it, especially when you have other packages such as react-query/swr, that although they perform a different function than the above, can sometimes remove the need for it.</p><p>PS. 2: Special thanks to the other two contributors of this repository (<a href=https://github.com/ferrybig><strong>ferrybig</strong></a> and <a href=https://github.com/Bonjur><strong>Bonjur</strong></a> for their invaluable input and suggestions!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://polmoreno.github.io/tags/attack/>attack</a></li><li><a href=https://polmoreno.github.io/tags/active-directory/>active directory</a></li><li><a href=https://polmoreno.github.io/tags/kerberos/>kerberos</a></li></ul><nav class=paginav><a class=next href=https://polmoreno.github.io/posts/enumerating_users/><span class=title>Next »</span><br><span>ENUMERATING USERS</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share AS-REP ROASTING on twitter" href="https://twitter.com/intent/tweet/?text=AS-REP%20ROASTING&url=https%3a%2f%2fpolmoreno.github.io%2fposts%2fas-rep-roasting%2f&hashtags=attack%2cactivedirectory%2ckerberos"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share AS-REP ROASTING on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fpolmoreno.github.io%2fposts%2fas-rep-roasting%2f&title=AS-REP%20ROASTING&summary=AS-REP%20ROASTING&source=https%3a%2f%2fpolmoreno.github.io%2fposts%2fas-rep-roasting%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share AS-REP ROASTING on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpolmoreno.github.io%2fposts%2fas-rep-roasting%2f&title=AS-REP%20ROASTING"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share AS-REP ROASTING on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpolmoreno.github.io%2fposts%2fas-rep-roasting%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share AS-REP ROASTING on whatsapp" href="https://api.whatsapp.com/send?text=AS-REP%20ROASTING%20-%20https%3a%2f%2fpolmoreno.github.io%2fposts%2fas-rep-roasting%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share AS-REP ROASTING on telegram" href="https://telegram.me/share/url?text=AS-REP%20ROASTING&url=https%3a%2f%2fpolmoreno.github.io%2fposts%2fas-rep-roasting%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://polmoreno.github.io>polmoreno</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=../../assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${t}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),window.REMARK42.changeTheme("light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),window.REMARK42.changeTheme("dark"))})</script></body></html>

</span></span></code></pre>
                </div>
                <p>You can see all of the above work, on its Github repository here:</p>
                <p><a
                        href=https://github.com/chrispanag/memoized-node-fetch>https://github.com/chrispanag/memoized-node-fetch</a>
                </p>
                <p>PS. 1: Although this can be used in the front-end, I can&rsquo;t find a very useful use-case for it,
                    especially when you have other packages such as react-query/swr, that although they perform a
                    different function than the above, can sometimes remove the need for it.</p>
                <p>PS. 2: Special thanks to the other two contributors of this repository (<a
                        href=https://github.com/ferrybig><strong>ferrybig</strong></a> and <a
                        href=https://github.com/Bonjur><strong>Bonjur</strong></a> for their invaluable input and
                    suggestions!</p>
            </div>
            <footer class=post-footer>
                <ul class=post-tags>
                    <li><a href=https://polmoreno.github.io/tags/attack />attack</a></li>
                    <li><a href=https://polmoreno.github.io/tags/active-directory />active directory</a></li>
                    <li><a href=https://polmoreno.github.io/tags/kerberos />kerberos</a></li>
                </ul>
                <nav class=paginav><a class=prev href=https://polmoreno.github.io/posts/scan_and_reconnaissance /><span
                        class=title>« Prev</span><br><span>RECONNAISSANCE AND SCAN</span></a>
                    <a class=next href=https://polmoreno.github.io/posts/kerberoasting /><span class=title>Next
                        »</span><br><span>KERBEROASTING</span></a>
                </nav>
            </footer>
        </article>
    </main>
    <footer class=footer><span>&copy; 2022 <a href=https://polmoreno.github.io>polmoreno</a></span>
        <span>&#183;</span>
        <span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
        <span>&#183;</span>
        <span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
    </footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link
            type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor">
                <path d="M12 6H0l6-6z" />
            </svg></button></a>
    <script defer src=../../assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js
        integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
    <script>window.onload = function () { localStorage.getItem("menu-scroll-position") && (document.getElementById("menu").scrollLeft = localStorage.getItem("menu-scroll-position")) }, document.querySelectorAll('a[href^="#"]').forEach(e => { e.addEventListener("click", function (e) { e.preventDefault(); var t = this.getAttribute("href").substr(1); window.matchMedia("(prefers-reduced-motion: reduce)").matches ? document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView() : document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({ behavior: "smooth" }), t === "top" ? history.replaceState(null, null, " ") : history.replaceState(null, null, `#${t}`) }) }); var mybutton = document.getElementById("top-link"); window.onscroll = function () { document.body.scrollTop > 800 || document.documentElement.scrollTop > 800 ? (mybutton.style.visibility = "visible", mybutton.style.opacity = "1") : (mybutton.style.visibility = "hidden", mybutton.style.opacity = "0") }; function menu_on_scroll() { localStorage.setItem("menu-scroll-position", document.getElementById("menu").scrollLeft) }</script>
    <script>document.getElementById("theme-toggle").addEventListener("click", () => { document.body.className.includes("dark") ? (document.body.classList.remove("dark"), localStorage.setItem("pref-theme", "light"), window.REMARK42.changeTheme("light")) : (document.body.classList.add("dark"), localStorage.setItem("pref-theme", "dark"), window.REMARK42.changeTheme("dark")) })</script>
</body>

</html>
 main
